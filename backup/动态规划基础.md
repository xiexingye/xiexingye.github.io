# 动态规划介绍
动态规划与分治类似，是将大问题分解成多个小问题，从而对于每个小问题进行最优选择，从而实现大问题的解决。

# 动态规划原理
能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。

## 最优子结构
1.证明问题最优解的第一个组成部分是做出一个选择；
2.对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；
3.给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；
4.证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。
## 无后效性
已经求解的子问题，不会再受到后续决策的影响。
## 子问题重叠
如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。

# 基本思路
1.将原问题划分为若干 阶段，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 状态）；
2.寻找每一个状态的可能 决策，或者说是各状态间的相互转移方式（用数学的语言描述就是 状态转移方程）。
3.按顺序求解每一个阶段的问题。

# 最长公共子序列
子序列是指从最初序列通过去除某些元素但不破坏余下元素的相对位置（在前或在后）而形成的新序列。
给定两个序列A和B，长度为$n$和$m$,让你求得两序列的最长公共子序列。
对于这个问题，我们只需要考虑A的前 $i$ 个元素和B的前 $j$ 个元素时的最长公共子序列状态，那么我们的dp数组就可以设置为 $dp[i][j]$,最终我们要求的也就是 $dp[n][m]$,即A和B序列全部遍历完后的答案。
对于这个问题，我们对与每一个字符有三种选择的方案。
1.如果 $A$ 和 $B$ 字符一样，那么就直接接上，因为他们相同。
2.如果不一样，那么就会出现两种决策，一种是接上A的字符，另一种是接上B的字符，或者说是跳过A或跳过B。
那么，根据这三种决策，我们就可以写出他的转移方程，即如果 $A==B$ ,那么 $dp[i][j]=dp[i-1][j-1]+1$ ,如果 $A!=B$ ,那么，$dp[i][j]=max(dp[i-1][j],dp[i][j-1])$ ,那么，我们也就可以根据状态转移方程轻松解决这题。

代码：
````
int a[MAXN], b[MAXM], f[MAXN][MAXM];

int dp() {
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
      if (a[i] == b[j])
        f[i][j] = f[i - 1][j - 1] + 1;
      else
        f[i][j] = std::max(f[i - 1][j], f[i][j - 1]);
  return f[n][m];
}
````
# 最长上升子序列
最长上升子序列指不递减的子序列。
题目为：给你一个序列 $A$ ,需要你找出长度最长的非递减子序列的长度。
这题我们可以很容易的想到，如果前一个数不大于后一个数，那么我们就把它接在前一个数后面，那么我们可以对前面每个数进行一次遍历。
因此，我们可以很容易的写出状态转移方程，即如果前一个数不大于后一个数, $dp[i]=max(dp[i],dp[j])$  。
代码：
````
int a[MAXN], d[MAXN];

int dp() {
  d[1] = 1;
  int ans = 1;
  for (int i = 2; i <= n; i++) {
    d[i] = 1;
    for (int j = 1; j < i; j++)
      if (a[j] <= a[i]) {
        d[i] = max(d[i], d[j] + 1);
        ans = max(ans, d[i]);
      }
  }
  return ans;
}
````
