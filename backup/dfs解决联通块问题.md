# 求联通块个数
求连通块个数思路：首先对整个图进行遍历，如果遍历到联通块，就让ans++，然后让其变为非连通块，然后对其搜索，将搜索到的这个联通块的所有格子全变为非连通块，然后退出搜索。
搜素思路：对每个格子的上下左右进行搜索，如果未被访问到且是连通块，就进行访问，并标记为已访问，然后让其变为非连通块，再进行搜索。


以洛谷P1451 求细胞数量为例
# 求细胞数量

##  题目描述

一矩形阵列由数字 $0$ 到 $9$ 组成，数字 $1$ 到 $9$ 代表细胞，细胞的定义为沿细胞数字上下左右若还是细胞数字则为同一细胞，求给定矩形阵列的细胞个数。

## 输入格式

第一行两个整数代表矩阵大小 $n$ 和 $m$。

接下来 $n$ 行，每行一个长度为 $m$ 的只含字符 `0` 到 `9` 的字符串，代表这个 $n \times m$ 的矩阵。

## 输出格式

一行一个整数代表细胞个数。

## 样例 #1

### 样例输入 #1

```
4 10
0234500067
1034560500
2045600671
0000000089
```

### 样例输出 #1

```
4
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le n,m \le 100$。

代码实现
```
#include<bits/stdc++.h>
using namespace std;
int n,m;
char a[100][100];
int v[100][100];
int ans=0;
char dx[4]={0,1,0,-1};
char dy[4]={1,0,-1,0}; 
void dfs(int x,int y){
	if(x>n||y>m||x<1||y<1){
		return;
	}
	for(int i=0;i<4;i++){
		int tx=x+dx[i];
		int ty=y+dy[i];
		if(v[tx][ty]==0&&a[tx][ty]!='0'){
			v[tx][ty]=1;
			a[tx][ty]='0';
			dfs(tx,ty);
			v[tx][ty]=0;
		} 
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		} 
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]!='0'){
				a[i][j]='0';
				ans++;
				dfs(i,j);
			}
		}
	}
	cout<<ans;
	return 0;
}
```
