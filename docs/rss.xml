<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>xxy</title><link>https://xiexingye.github.io</link><description>童话是一种生活态度，仅此而已。</description><copyright>xxy</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://xiexingye.github.io</link></image><lastBuildDate>Tue, 12 Nov 2024 11:49:27 +0000</lastBuildDate><managingEditor>xxy</managingEditor><ttl>60</ttl><webMaster>xxy</webMaster><item><title>动态规划（1）---背包问题</title><link>https://xiexingye.github.io/post/dong-tai-gui-hua-%EF%BC%881%EF%BC%89----bei-bao-wen-ti.html</link><description># 01背包问题&#13;
```&#13;
for(int i=1;i&lt;=n;i++){&#13;
for(int j=W;j&gt;=w[i];j++){&#13;
dp[j]=max(dp[j],dp[j-w[i]]+v[i]);&#13;
}&#13;
}&#13;
```&#13;
&#13;
# 完全背包问题&#13;
```&#13;
for(int i=1;i&lt;=n;i++){&#13;
for(int j=w[i];j&lt;=W;j++){&#13;
dp[j]=max(dp[j],dp[j-w[i])+v[i]);&#13;
}&#13;
}&#13;
```&#13;
&#13;
# 多重背包&#13;
```&#13;
for(int i=1;i&lt;=N;i++){&#13;
for(int j=W;j&gt;=w[i];j--){&#13;
for(int k=0;k&lt;min(n[i],j/w[i]);k++){&#13;
dp[j]=max(dp[j],dp[j-k*w[i]]+k*v[i]);&#13;
}&#13;
}&#13;
}&#13;
```。</description><guid isPermaLink="true">https://xiexingye.github.io/post/dong-tai-gui-hua-%EF%BC%881%EF%BC%89----bei-bao-wen-ti.html</guid><pubDate>Tue, 12 Nov 2024 11:49:00 +0000</pubDate></item><item><title>并查集</title><link>https://xiexingye.github.io/post/bing-cha-ji.html</link><description># 定义&#13;
并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</description><guid isPermaLink="true">https://xiexingye.github.io/post/bing-cha-ji.html</guid><pubDate>Tue, 12 Nov 2024 11:47:44 +0000</pubDate></item><item><title>树状数组</title><link>https://xiexingye.github.io/post/shu-zhuang-shu-zu.html</link><description># 树状数组是一种支持 单点修改 和 区间查询 的，代码量小的数据结构。</description><guid isPermaLink="true">https://xiexingye.github.io/post/shu-zhuang-shu-zu.html</guid><pubDate>Tue, 12 Nov 2024 11:47:12 +0000</pubDate></item><item><title>DFS算法(2)----迷宫问题</title><link>https://xiexingye.github.io/post/DFS-suan-fa-%282%29-----mi-gong-wen-ti.html</link><description># dfs算法解决迷宫问题&#13;
```&#13;
#include&lt;iostream&gt;&#13;
using namespace std;&#13;
int dx[4] = { 0,1,0,-1 };&#13;
int dy[4] = { 1,0,-1,0 };&#13;
int a[100][100];&#13;
int n, m;&#13;
int v[100][100];&#13;
int min = 1000000;&#13;
void dfs(int x, int y, int step) {&#13;
	if (x == n &amp;&amp; y == m) {&#13;
		if (step &lt; min) {&#13;
			min = step;&#13;
		}&#13;
		return;&#13;
	}&#13;
	for (int i = 0; i &lt; 4; i++) {&#13;
		int tx = x + dx[i];&#13;
		int ty = y + dy[i];&#13;
		if (a[tx][ty] == 1 &amp;&amp; v[tx][ty] == 0) {&#13;
			v[tx][ty] = 1;&#13;
			dfs(tx, ty, step + 1);&#13;
			v[tx][ty] = 0;&#13;
		}&#13;
	}&#13;
}&#13;
int main()&#13;
{&#13;
	cin &gt;&gt; n &gt;&gt; m;&#13;
	&#13;
	for (int i = 0; i &lt; n; i++) {&#13;
		for (int j = 0; j &lt; m; j++) {&#13;
			cin &gt;&gt; a[i][j];&#13;
		}&#13;
	}&#13;
	v[0][0] = 1;&#13;
	dfs(0, 0, 0);&#13;
	return 0;&#13;
}&#13;
```。</description><guid isPermaLink="true">https://xiexingye.github.io/post/DFS-suan-fa-%282%29-----mi-gong-wen-ti.html</guid><pubDate>Tue, 12 Nov 2024 11:46:20 +0000</pubDate></item><item><title>DFS算法(1)</title><link>https://xiexingye.github.io/post/DFS-suan-fa-%281%29.html</link><description># 深度优先算法的优点与思想&#13;
深度优先算法，是利用递推和递归实现的暴力搜索算法。</description><guid isPermaLink="true">https://xiexingye.github.io/post/DFS-suan-fa-%281%29.html</guid><pubDate>Tue, 12 Nov 2024 11:45:12 +0000</pubDate></item><item><title>排序(五种）</title><link>https://xiexingye.github.io/post/pai-xu-%28-wu-zhong-%EF%BC%89.html</link><description># 1、选择排序&#13;
算法思路：将每个数与自己后面的数一一比较，如果大就继续交换，如果小，就继续向后比，如果自己最小，就不变位置。</description><guid isPermaLink="true">https://xiexingye.github.io/post/pai-xu-%28-wu-zhong-%EF%BC%89.html</guid><pubDate>Tue, 12 Nov 2024 11:44:00 +0000</pubDate></item><item><title>Codeforces Round 984 (Div. 3)个人题解C,D</title><link>https://xiexingye.github.io/post/Codeforces%20Round%20984%20%28Div.%203%29-ge-ren-ti-jie-C%2CD.html</link><description># C&#13;
本题思路：暴力枚举，但是要进行优化，不然会超时间复杂度&#13;
优化策略：首先记录符合1100模式的字符串的首字符的位置，然后在查询时候，我们只需要修改的前后位置并修改就行。</description><guid isPermaLink="true">https://xiexingye.github.io/post/Codeforces%20Round%20984%20%28Div.%203%29-ge-ren-ti-jie-C%2CD.html</guid><pubDate>Tue, 12 Nov 2024 11:11:31 +0000</pubDate></item><item><title>111</title><link>https://xiexingye.github.io/post/111.html</link><description>111。</description><guid isPermaLink="true">https://xiexingye.github.io/post/111.html</guid><pubDate>Sun, 11 Aug 2024 15:30:08 +0000</pubDate></item></channel></rss>