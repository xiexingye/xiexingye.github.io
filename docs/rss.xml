<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>xxy</title><link>https://xiexingye.github.io</link><description>童话是一种生活态度，仅此而已。</description><copyright>xxy</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://xiexingye.github.io</link></image><lastBuildDate>Tue, 12 Nov 2024 13:19:03 +0000</lastBuildDate><managingEditor>xxy</managingEditor><ttl>60</ttl><webMaster>xxy</webMaster><item><title>字符串基础概念</title><link>https://xiexingye.github.io/post/zi-fu-chuan-ji-chu-gai-nian.html</link><description># Border&#13;
border指一个字符串的前缀和后缀相同，则其为border。</description><guid isPermaLink="true">https://xiexingye.github.io/post/zi-fu-chuan-ji-chu-gai-nian.html</guid><pubDate>Tue, 12 Nov 2024 13:18:23 +0000</pubDate></item><item><title>splay树</title><link>https://xiexingye.github.io/post/splay-shu.html</link><description># splay树&#13;
平衡树的一种，自身可以通过旋转来降低树的深度&#13;
&#13;
&#13;
# 普通平衡树模板&#13;
````&#13;
#include&lt;iostream&gt;&#13;
#include&lt;cstdio&gt;&#13;
#include&lt;queue&gt;&#13;
#include&lt;cstring&gt;&#13;
#include&lt;algorithm&gt;&#13;
#include&lt;climits&gt;&#13;
typedef long long LL;&#13;
using namespace std;&#13;
int RD(){&#13;
    int out = 0,flag = 1;char c = getchar();&#13;
    while(c &lt; '0' || c &gt;'9'){if(c == '-')flag = -1;c = getchar();}&#13;
    while(c &gt;= '0' &amp;&amp; c &lt;= '9'){out = out * 10 + c - '0';c = getchar();}&#13;
    return flag * out;&#13;
    }&#13;
//第一次打treap，不压行写注释XD&#13;
const int maxn = 1000019,INF = 1e9;&#13;
//平衡树，利用BST性质查询和修改，利用随机和堆优先级来保持平衡，把树的深度控制在log N，保证了操作效率&#13;
//基本平衡树有以下几个比较重要的函数：新建，插入，删除，旋转&#13;
//节点的基本属性有val(值)，dat(随机出来的优先级)&#13;
//通过增加属性，结合BST的性质可以达到一些效果，如size(子树大小，查询排名)，cnt(每个节点包含的副本数)等&#13;
int na;&#13;
int ch[maxn][2];//[i][0]代表i左儿子，[i][1]代表i右儿子&#13;
int val[maxn],dat[maxn];&#13;
int size[maxn],cnt[maxn];&#13;
int tot,root;&#13;
int New(int v){//新增节点，&#13;
	val[++tot] = v;//节点赋值&#13;
	dat[tot] = rand();//随机优先级&#13;
	size[tot] = 1;//目前是新建叶子节点，所以子树大小为1&#13;
	cnt[tot] = 1;//新建节点同理副本数为1&#13;
	return tot;&#13;
	}&#13;
void pushup(int id){//和线段树的pushup更新一样&#13;
	size[id] = size[ch[id][0]] + size[ch[id][1]] + cnt[id];//本节点子树大小 = 左儿子子树大小 + 右儿子子树大小 + 本节点副本数&#13;
	}&#13;
void build(){&#13;
	root = New(-INF),ch[root][1] = New(INF);//先加入正无穷和负无穷，便于之后操作(貌似不加也行)&#13;
	pushup(root);//因为INF &gt; -INF,所以是右子树，&#13;
	}&#13;
void Rotate(int &amp;id,int d){//id是引用传递，d(irection)为旋转方向，0为左旋，1为右旋&#13;
	int temp = ch[id][d ^ 1];//旋转理解：找个动图看一看就好(或参见其他OIer的blog)&#13;
	ch[id][d ^ 1] = ch[temp][d];//这里讲一个记忆技巧，这些数据都是被记录后马上修改&#13;
	ch[temp][d] = id;//所以像“Z”一样&#13;
	id = temp;//比如这个id，在上一行才被记录过，ch[temp][d]、ch[id][d ^ 1]也是一样的&#13;
	pushup(ch[id][d]),pushup(id);//旋转以后size会改变，看图就会发现只更新自己和转上来的点，pushup一下,注意先子节点再父节点&#13;
	}//旋转实质是({在满足BST的性质的基础上比较优先级}通过交换本节点和其某个叶子节点)把链叉开成二叉形状(从而控制深度)，可以看图理解一下&#13;
void insert(int &amp;id,int v){//id依然是引用，在新建节点时可以体现&#13;
	if(!id){&#13;
		id = New(v);//若节点为空，则新建一个节点&#13;
		return ;&#13;
		}&#13;
	if(v == val[id])cnt[id]++;//若节点已存在，则副本数++;&#13;
	else{//要满足BST性质，小于插到左边，大于插到右边&#13;
		int d = v &lt; val[id] ? 0 : 1;//这个d是方向的意思，按照BST的性质，小于本节点则向左，大于向右&#13;
		insert(ch[id][d],v);//递归实现&#13;
		if(dat[id] &lt; dat[ch[id][d]])Rotate(id,d ^ 1);//(参考一下图)与左节点交换右旋，与右节点交换左旋&#13;
		}&#13;
	pushup(id);//现在更新一下本节点的信息&#13;
	}&#13;
void Remove(int &amp;id,int v){//最难de部分了&#13;
	if(!id)return ;//到这了发现查不到这个节点，该点不存在，直接返回&#13;
	if(v == val[id]){//检索到了这个值&#13;
		if(cnt[id] &gt; 1){cnt[id]--,pushup(id);return ;}//若副本不止一个，减去一个就好&#13;
		if(ch[id][0] || ch[id][1]){//发现只有一个值，且有儿子节点,我们只能把值旋转到底部删除&#13;
			if(!ch[id][1] || dat[ch[id][0]] &gt; dat[ch[id][1]]){//当前点被移走之后，会有一个新的点补上来(左儿子或右儿子)，按照优先级，优先级大的补上来&#13;
				Rotate(id,1),Remove(ch[id][1],v);//我们会发现，右旋是与左儿子交换，当前点变成右节点；左旋则是与右儿子交换，当前点变为左节点&#13;
				}&#13;
			else Rotate(id,0),Remove(ch[id][0],v);&#13;
			pushup(id);&#13;
			}&#13;
		else id = 0;//发现本节点是叶子节点，直接删除&#13;
		return ;//这个return对应的是检索到值de所有情况&#13;
		}&#13;
	v &lt; val[id] ? Remove(ch[id][0],v) : Remove(ch[id][1],v);//继续BST性质&#13;
	pushup(id);&#13;
	}&#13;
int get_rank(int id,int v){&#13;
	if(!id)return 1;//若查询值不存在，返回；因为最后要减一排除哨兵节点，想要结果为-1这里就返回0&#13;
	if(v == val[id])return size[ch[id][0]] + 1;//查询到该值，由BST性质可知：该点左边值都比该点的值(查询值)小，故rank为左儿子大小 + 1&#13;
	else if(v &lt; val[id])return get_rank(ch[id][0],v);//发现需查询的点在该点左边，往左边递归查询&#13;
	else return size[ch[id][0]] + cnt[id] + get_rank(ch[id][1],v);//若查询值大于该点值。</description><guid isPermaLink="true">https://xiexingye.github.io/post/splay-shu.html</guid><pubDate>Tue, 12 Nov 2024 13:17:39 +0000</pubDate></item><item><title>二叉搜索树</title><link>https://xiexingye.github.io/post/er-cha-sou-suo-shu.html</link><description># 二叉搜索树功能 &#13;
复杂度O(logn)&#13;
能够实现&#13;
插入一个数&#13;
删除一个数&#13;
查询某数的排名（排名定义为比该数小的数的个数+1）&#13;
查询指定排名的数&#13;
求某数的前驱（前驱定义为小于该数，且最大的数）&#13;
求某数的后继（后继定义为大于该数，且最小的数）&#13;
&#13;
# 插入&#13;
从根节点开始，递归地搜索。</description><guid isPermaLink="true">https://xiexingye.github.io/post/er-cha-sou-suo-shu.html</guid><pubDate>Tue, 12 Nov 2024 13:16:18 +0000</pubDate></item><item><title>lca倍增优化板子</title><link>https://xiexingye.github.io/post/lca-bei-zeng-you-hua-ban-zi.html</link><description>```&#13;
#include&lt;bits/stdc++.h&gt;&#13;
using namespace std;&#13;
#define N 500005&#13;
#define endl '\n'&#13;
int head[N], to[N&lt;&lt;1], nex[N&lt;&lt;1], cnt=1;&#13;
int fa[N][21], dep[N];&#13;
void add(int x, int y){&#13;
	to[cnt] = y;&#13;
	nex[cnt] = head[x];&#13;
	head[x] = cnt++;&#13;
}&#13;
void dfs(int rt, int f){&#13;
	dep[rt] = dep[f] + 1;&#13;
	fa[rt][0] = f;&#13;
	for(int i = 1; (1 &lt;&lt; i) &lt;= dep[rt]; i++){ &#13;
		fa[rt][i] = fa[fa[rt][i - 1]][i - 1];&#13;
	}&#13;
	for(int i = head[rt]; i; i = nex[i]){&#13;
		if(to[i] == f){&#13;
			continue;&#13;
		}&#13;
		dfs(to[i], rt);&#13;
	}&#13;
}&#13;
int LCA(int x, int y){&#13;
	if(dep[x] &lt; dep[y]){&#13;
		swap(x, y);&#13;
	}&#13;
	for(int i = 20; i &gt;= 0; i--){  &#13;
		if(dep[fa[x][i]] &gt;= dep[y]){&#13;
			x = fa[x][i];&#13;
		}&#13;
	} &#13;
	if(x == y){  &#13;
		return x;&#13;
	}&#13;
	for(int i = 20; i &gt;= 0; i--){   &#13;
		if(fa[x][i] != fa[y][i]){&#13;
			x = fa[x][i];&#13;
			y = fa[y][i];&#13;
		}&#13;
	}&#13;
	return fa[x][0];  &#13;
}&#13;
int main(){&#13;
	ios::sync_with_stdio(false);&#13;
	int n, m, s;&#13;
	while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; s){&#13;
		memset(head, 0, sizeof(head));&#13;
		cnt = 1;&#13;
		int x, y;&#13;
		for(int i = 0; i &lt; n - 1; i++){&#13;
			cin &gt;&gt; x &gt;&gt; y;&#13;
			add(x, y);&#13;
			add(y, x);&#13;
		}&#13;
		dfs(s, 0);&#13;
		for(int i = 0; i &lt; m; i++){&#13;
			cin &gt;&gt; x &gt;&gt; y;&#13;
			cout &lt;&lt; LCA(x, y) &lt;&lt; endl;&#13;
		}&#13;
	}&#13;
	return 0;&#13;
}&#13;
```。</description><guid isPermaLink="true">https://xiexingye.github.io/post/lca-bei-zeng-you-hua-ban-zi.html</guid><pubDate>Tue, 12 Nov 2024 11:51:42 +0000</pubDate></item><item><title>dijkstra板子</title><link>https://xiexingye.github.io/post/dijkstra-ban-zi.html</link><description>```&#13;
/*&#13;
1.声明dis[],vis[],f[][]，dis用于记录从起点到i的最短路,vis标记是否用过,f用于存储前驱到后驱的权值&#13;
2.初始化dis[]为无穷大（INF）以及dis[起点]=0,用变量t=-1来表示距离起点最近且未标记的点&#13;
如果dist[j]&lt;dist[t]，说明找到了距离起点更近的点，更新t，然后标记vis[t]&#13;
3. 比较距离找出最小的dis[]&#13;
*/&#13;
#include &lt;bits/stdc++.h&gt;&#13;
#define MOD 10000000007&#13;
#define INF 0x3f3f3f3f&#13;
using namespace std;&#13;
typedef long long LL;&#13;
int n,m,s;//n是顶点数，m是边数，s是起点&#13;
int u,v,w;&#13;
LL dis[10005],vis[10005],f[10001][10001];//dis用于记录从起点到i的最短路,vis标记是否用过,f用于存储前驱到后驱的权值&#13;
void dijkstra() {&#13;
	//初始化&#13;
	memset(dis,INF,sizeof(dis));&#13;
	dis[s]=0;//起点到自己当然是0&#13;
	for(int i=1; i&lt;=n; i++) {&#13;
		int t=-1;//用于找第一个未被标记的点&#13;
		for(int j=1; j&lt;=n; j++)&#13;
			if(!vis[j] &amp;&amp; (t==-1 || dis[j]&lt;dis[t])) t=j;//未标记或找到更近的&#13;
		vis[t]=1;//标记，防止再次计算&#13;
		for(int j=1; j&lt;=n; j++) {&#13;
			dis[j] = min(dis[j],dis[t]+f[t][j]);&#13;
		}&#13;
		cout&lt;&lt;endl;&#13;
	}&#13;
}&#13;
int main() {&#13;
	memset(f,INF,sizeof(f));//初始化到无穷（求最短路）&#13;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;&#13;
	for(int i=1; i&lt;=m; i++) {&#13;
		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;&#13;
		f[u][v]=w;//从u到v的花费为w&#13;
	}&#13;
	dijkstra();&#13;
	for(int i=1; i&lt;=n; i++)&#13;
		cout&lt;&lt;dis[i]&lt;&lt;' ';&#13;
	return 0;&#13;
}&#13;
```。</description><guid isPermaLink="true">https://xiexingye.github.io/post/dijkstra-ban-zi.html</guid><pubDate>Tue, 12 Nov 2024 11:50:55 +0000</pubDate></item><item><title>bfs解决迷宫问题板子</title><link>https://xiexingye.github.io/post/bfs-jie-jue-mi-gong-wen-ti-ban-zi.html</link><description>```&#13;
#include&lt;bits/stdc++.h&gt;&#13;
using namespace std;&#13;
int n,m;&#13;
int startx,starty;&#13;
int dx[4]={0,1,0,-1};&#13;
int dy[4]={1,0,-1,0};&#13;
int a[100][100];&#13;
int v[100][100];&#13;
int flag=0;&#13;
struct point&#13;
{&#13;
	int x;&#13;
	int y;&#13;
	int step;&#13;
};&#13;
queue&lt;point&gt; r;&#13;
int main()&#13;
{&#13;
	cin&gt;&gt;n&gt;&gt;m;&#13;
	cin&gt;&gt;startx&gt;&gt;starty;&#13;
	for(int i=1;i&lt;=n;i++){&#13;
		for(int j=1;j&lt;=m;j++){&#13;
			cin&gt;&gt;a[i][j];&#13;
		} &#13;
	}&#13;
	point start;&#13;
	start.x=startx;&#13;
	start.y=starty;&#13;
	start.step=0;&#13;
	r.push(start);&#13;
	v[startx][starty]=1;&#13;
	while(!r.empty()){&#13;
		int x=r.front().x;&#13;
		int y=r.front().y;&#13;
		int step=r.front().step;&#13;
		if(x==n&amp;&amp;y==m){&#13;
			flag=1;&#13;
			cout&lt;&lt;r.front().step;&#13;
			break;&#13;
		}&#13;
		for(int i=0;i&lt;4;i++){&#13;
			int tx=x+dx[i];&#13;
			int ty=y+dy[i];&#13;
			if(v[tx][ty]==0&amp;&amp;a[tx][ty]==1){&#13;
				point temp;&#13;
				temp.x=tx;&#13;
				temp.y=ty;&#13;
				temp.step=r.front().step+1;&#13;
				r.push(temp);&#13;
				v[tx][ty]=1;&#13;
			}&#13;
		}&#13;
		r.pop();&#13;
	}&#13;
	if(flag==0){&#13;
		cout&lt;&lt;'-1';&#13;
	}&#13;
	return 0;&#13;
}&#13;
```。</description><guid isPermaLink="true">https://xiexingye.github.io/post/bfs-jie-jue-mi-gong-wen-ti-ban-zi.html</guid><pubDate>Tue, 12 Nov 2024 11:50:32 +0000</pubDate></item><item><title>dfs解决联通块问题</title><link>https://xiexingye.github.io/post/dfs-jie-jue-lian-tong-kuai-wen-ti.html</link><description># 求联通块个数&#13;
求连通块个数思路：首先对整个图进行遍历，如果遍历到联通块，就让ans++，然后让其变为非连通块，然后对其搜索，将搜索到的这个联通块的所有格子全变为非连通块，然后退出搜索。</description><guid isPermaLink="true">https://xiexingye.github.io/post/dfs-jie-jue-lian-tong-kuai-wen-ti.html</guid><pubDate>Tue, 12 Nov 2024 11:49:39 +0000</pubDate></item><item><title>动态规划（1）---背包问题</title><link>https://xiexingye.github.io/post/dong-tai-gui-hua-%EF%BC%881%EF%BC%89----bei-bao-wen-ti.html</link><description># 01背包问题&#13;
```&#13;
for(int i=1;i&lt;=n;i++){&#13;
for(int j=W;j&gt;=w[i];j++){&#13;
dp[j]=max(dp[j],dp[j-w[i]]+v[i]);&#13;
}&#13;
}&#13;
```&#13;
&#13;
# 完全背包问题&#13;
```&#13;
for(int i=1;i&lt;=n;i++){&#13;
for(int j=w[i];j&lt;=W;j++){&#13;
dp[j]=max(dp[j],dp[j-w[i])+v[i]);&#13;
}&#13;
}&#13;
```&#13;
&#13;
# 多重背包&#13;
```&#13;
for(int i=1;i&lt;=N;i++){&#13;
for(int j=W;j&gt;=w[i];j--){&#13;
for(int k=0;k&lt;min(n[i],j/w[i]);k++){&#13;
dp[j]=max(dp[j],dp[j-k*w[i]]+k*v[i]);&#13;
}&#13;
}&#13;
}&#13;
```。</description><guid isPermaLink="true">https://xiexingye.github.io/post/dong-tai-gui-hua-%EF%BC%881%EF%BC%89----bei-bao-wen-ti.html</guid><pubDate>Tue, 12 Nov 2024 11:49:00 +0000</pubDate></item><item><title>并查集</title><link>https://xiexingye.github.io/post/bing-cha-ji.html</link><description># 定义&#13;
并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</description><guid isPermaLink="true">https://xiexingye.github.io/post/bing-cha-ji.html</guid><pubDate>Tue, 12 Nov 2024 11:47:44 +0000</pubDate></item><item><title>树状数组</title><link>https://xiexingye.github.io/post/shu-zhuang-shu-zu.html</link><description># 树状数组是一种支持 单点修改 和 区间查询 的，代码量小的数据结构。</description><guid isPermaLink="true">https://xiexingye.github.io/post/shu-zhuang-shu-zu.html</guid><pubDate>Tue, 12 Nov 2024 11:47:12 +0000</pubDate></item><item><title>DFS算法(2)----迷宫问题</title><link>https://xiexingye.github.io/post/DFS-suan-fa-%282%29-----mi-gong-wen-ti.html</link><description># dfs算法解决迷宫问题&#13;
```&#13;
#include&lt;iostream&gt;&#13;
using namespace std;&#13;
int dx[4] = { 0,1,0,-1 };&#13;
int dy[4] = { 1,0,-1,0 };&#13;
int a[100][100];&#13;
int n, m;&#13;
int v[100][100];&#13;
int min = 1000000;&#13;
void dfs(int x, int y, int step) {&#13;
	if (x == n &amp;&amp; y == m) {&#13;
		if (step &lt; min) {&#13;
			min = step;&#13;
		}&#13;
		return;&#13;
	}&#13;
	for (int i = 0; i &lt; 4; i++) {&#13;
		int tx = x + dx[i];&#13;
		int ty = y + dy[i];&#13;
		if (a[tx][ty] == 1 &amp;&amp; v[tx][ty] == 0) {&#13;
			v[tx][ty] = 1;&#13;
			dfs(tx, ty, step + 1);&#13;
			v[tx][ty] = 0;&#13;
		}&#13;
	}&#13;
}&#13;
int main()&#13;
{&#13;
	cin &gt;&gt; n &gt;&gt; m;&#13;
	&#13;
	for (int i = 0; i &lt; n; i++) {&#13;
		for (int j = 0; j &lt; m; j++) {&#13;
			cin &gt;&gt; a[i][j];&#13;
		}&#13;
	}&#13;
	v[0][0] = 1;&#13;
	dfs(0, 0, 0);&#13;
	return 0;&#13;
}&#13;
```。</description><guid isPermaLink="true">https://xiexingye.github.io/post/DFS-suan-fa-%282%29-----mi-gong-wen-ti.html</guid><pubDate>Tue, 12 Nov 2024 11:46:20 +0000</pubDate></item><item><title>DFS算法(1)</title><link>https://xiexingye.github.io/post/DFS-suan-fa-%281%29.html</link><description># 深度优先算法的优点与思想&#13;
深度优先算法，是利用递推和递归实现的暴力搜索算法。</description><guid isPermaLink="true">https://xiexingye.github.io/post/DFS-suan-fa-%281%29.html</guid><pubDate>Tue, 12 Nov 2024 11:45:12 +0000</pubDate></item><item><title>排序(五种）</title><link>https://xiexingye.github.io/post/pai-xu-%28-wu-zhong-%EF%BC%89.html</link><description># 1、选择排序&#13;
算法思路：将每个数与自己后面的数一一比较，如果大就继续交换，如果小，就继续向后比，如果自己最小，就不变位置。</description><guid isPermaLink="true">https://xiexingye.github.io/post/pai-xu-%28-wu-zhong-%EF%BC%89.html</guid><pubDate>Tue, 12 Nov 2024 11:44:00 +0000</pubDate></item><item><title>Codeforces Round 984 (Div. 3)个人题解C,D</title><link>https://xiexingye.github.io/post/Codeforces%20Round%20984%20%28Div.%203%29-ge-ren-ti-jie-C%2CD.html</link><description># C&#13;
本题思路：暴力枚举，但是要进行优化，不然会超时间复杂度&#13;
优化策略：首先记录符合1100模式的字符串的首字符的位置，然后在查询时候，我们只需要修改的前后位置并修改就行。</description><guid isPermaLink="true">https://xiexingye.github.io/post/Codeforces%20Round%20984%20%28Div.%203%29-ge-ren-ti-jie-C%2CD.html</guid><pubDate>Tue, 12 Nov 2024 11:11:31 +0000</pubDate></item><item><title>111</title><link>https://xiexingye.github.io/post/111.html</link><description>111。</description><guid isPermaLink="true">https://xiexingye.github.io/post/111.html</guid><pubDate>Sun, 11 Aug 2024 15:30:08 +0000</pubDate></item></channel></rss>